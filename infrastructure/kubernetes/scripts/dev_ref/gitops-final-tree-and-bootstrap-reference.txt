# GitOps (k3d + AKS-like) â€” Estrutura Final Recomendada (Platform + Apps)

## Objetivo
- Bootstrap mÃ­nimo (host-level): cria cluster k3d + instala ArgoCD
- GitOps real (cluster-level): ArgoCD gerencia toda a stack (observability, autoscaling e apps)
- OrganizaÃ§Ã£o por domÃ­nio: platform vs apps
- Suporte a ambientes: dev e prod (overlays + values por ambiente)
- MantÃ©m a lÃ³gica que vocÃª jÃ¡ validou: base/overlays + bootstrap "app-of-apps"

---

âœ… Primeiro: â€œmanifestsâ€ vs â€œargocd-appsâ€ â€” qual nome Ã© melhor?
Minha opiniÃ£o: nÃ£o use â€œmanifestsâ€ como pasta principal

Porque â€œmanifestsâ€ vira uma pasta â€œcoringaâ€ onde tudo vai parar (ingress, app, secrets, patches, etc).
Ela funciona, mas tende a virar bagunÃ§a com o tempo.

Melhor naming (padrÃ£o GitOps moderno):

âœ… argocd/ (ou bootstrap/argocd/) para tudo que Ã© ArgoCD â€œdeclarativoâ€

Applications / ApplicationSets

Projects

Repos credentials (se tiver)

App-of-apps bootstrap

E usar:
âœ… base/ e overlays/ para recursos Kubernetes â€œgenÃ©ricosâ€ (Kustomize)

ğŸ“Œ EntÃ£o a resposta Ã©:

â€œargocd-appsâ€ Ã© um nome bom, mas eu prefiro argocd/ (mais curto e padrÃ£o)

â€œmanifestsâ€ eu deixaria apenas como nome de base (se vocÃª quiser), mas nÃ£o como â€œpasta de tudoâ€

âœ… O melhor desenho (mantendo sua lÃ³gica base/overlays + ArgoCD bootstrap)

A forma mais consistente Ã©:

1) Separar â€œPlatformâ€ vs â€œAppsâ€

Porque a plataforma (observability, ingress, cert-manager, keda) tem ciclo de vida diferente das apps.

Platform = coisas que habilitam o cluster
Apps = seu produto

Isso deixa o time muito mais organizado.

ğŸ“Œ Estrutura recomendada (parecida com a sua, sÃ³ refinada)

Por que isso Ã© melhor?

mantÃ©m base/overlays (sua lÃ³gica vencedora)

mantÃ©m â€œplatformâ€ separado de â€œappsâ€

mantÃ©m â€œArgoCD bootstrapâ€ separado e claro

mantÃ©m values por ambiente (dev/prod) de forma explÃ­cita

deixa pronto pra crescer sem virar â€œpasta manifests infinitaâ€

ğŸ§  Onde entram Helm values nesse modelo?

VocÃª tem 2 formas boas (vou te dizer a melhor).

âœ… Melhor opÃ§Ã£o: helm-values/dev e helm-values/prod

Isso Ã© perfeito porque:

dev usa limits mais baixos

prod usa limits realistas

e o arquivo â€œconta a histÃ³ria do ambienteâ€

ğŸ“Œ Exemplo:

dev: Prometheus com retenÃ§Ã£o curta e baixo consumo

prod: retenÃ§Ã£o maior, replicas, requests maiores

Isso Ã© o que times maduros fazem.

âš™ï¸ Como o ArgoCD aplica Helm values + Kustomize juntos?

O padrÃ£o Ã©:

Platform apps (observability etc) â†’ ArgoCD Application usando Helm

aponta pro chart (repo Helm)

usa valueFiles do seu git (ex: infrastructure/kubernetes/platform/helm-values/dev/loki.values.yaml)

Apps do produto â†’ ArgoCD Application usando Kustomize

aponta pra pasta overlay (apps/overlays/dev)

Ou seja:

Helm pra plataforma

Kustomize pros seus serviÃ§os (ou Helm tambÃ©m, se vocÃª preferir)

Isso fica limpo e muito consistente.

ğŸ¯ E o â€œapplication-bootstrap.yamlâ€ como no seu projeto antigo?

MantÃ©m! SÃ³ que com nome mais claro.

Eu recomendo:

âœ… argocd/bootstrap/application-bootstrap.yaml

Esse arquivo Ã© o â€œstart buttonâ€ do GitOps.

Ele pode ser:

1 Application â€œrootâ€ que cria os outros (App-of-apps)
ou

1 ApplicationSet que gera tudo (platform + apps)

ğŸ“Œ Minha preferÃªncia:

Bootstrap com App-of-apps (simples e explÃ­cito)

e dentro dele, aplicaÃ§Ãµes separadas por domÃ­nio (observability/autoscaling/apps)

ğŸ“Œ Sobre â€œ1 ApplicationSet vs vÃ¡riosâ€

Aqui mantÃ©m o que eu recomendei antes:

âœ… separado por domÃ­nio Ã© melhor pro time

Ex:

platform-observability.yaml

platform-autoscaling.yaml

apps-dev.yaml

apps-prod.yaml

VocÃª ganha:

rollback isolado

ownership

troubleshooting melhor

âœ… EntÃ£o qual Ã© â€œo melhorâ€ formato final?

Se eu tivesse que bater o martelo pelo seu time:

ğŸ”¥ Melhor decisÃ£o

Manter base/ e overlays/ (vocÃª jÃ¡ validou que funciona)

Criar duas Ã¡reas:

platform/ (infra do cluster)

apps/ (seus microserviÃ§os)

Trocar manifests/ por argocd/

application-bootstrap.yaml continua existindo, sÃ³ que em:

platform/argocd/bootstrap/

(e opcionalmente apps/argocd/bootstrap/)

Helm values ficam em:

platform/helm-values/dev e platform/helm-values/prod

Minha opiniÃ£o â€œbem pÃ© no chÃ£oâ€

O seu modelo antigo era bom porque:

Kustomize forÃ§a organizaÃ§Ã£o

overlays dev/prod deixam explÃ­cito o que muda

bootstrap Ã© um ponto Ãºnico de entrada

O que vocÃª precisa agora Ã© sÃ³ â€œmodernizarâ€:

parar de chamar de manifests o que Ã© â€œArgoCD stateâ€

criar uma pasta clara argocd/

encaixar Helm values por ambiente

Se vocÃª quiser, eu monto agora a Ã¡rvore final completa jÃ¡ com:

application-bootstrap.yaml (App-of-apps)

platform-observability.yaml (Helm: prom/grafana/loki/tempo/otel)

platform-autoscaling.yaml (Helm: keda)

e um README com o fluxo â€œ1 comando bootstrap e o resto Ã© GitOpsâ€

## ğŸ“ Ãrvore Final (Recomendada)

tc-agro-solutions/
â””â”€â”€ infrastructure/
    â”œâ”€â”€ kubernetes/
    â”‚   | â”œâ”€â”€ scripts/
    â”‚   |   â””â”€â”€ k3d/
    â”‚   |      â”œâ”€â”€ k3d-manager.ps1               # Cria cluster + instala ArgoCD + aplica bootstrap app-of-apps (aqui manter e reaproveitar todos os scripts, se limitando em instalar apenas via ps1 criar cluster + instalar argocd, da pasta atual scripts/dev de bootstrap-argocd-apps, build-push-images, cleanup-all,create-all-from-zero, k3d-manager, list-secrets, port-forward, start-cluster, stop-port-forward, update-hosts-file)
    â”‚   â”œâ”€â”€ platform/
    â”‚   â”‚   â”œâ”€â”€ README.md
    â”‚   â”‚   â”‚
    â”‚   â”‚   â”œâ”€â”€ base/
    â”‚   â”‚   â”‚   â”œâ”€â”€ namespaces/
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ namespaces.yaml
    â”‚   â”‚   â”‚   â”œâ”€â”€ kustomization.yaml
    â”‚   â”‚   â”‚   â””â”€â”€ system-pod-tolerations.yaml
    â”‚   â”‚   â”‚
    â”‚   â”‚   â”œâ”€â”€ overlays/
    â”‚   â”‚   â”‚   â”œâ”€â”€ dev/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ kustomization.yaml
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ patches/
    â”‚   â”‚   â”‚   â”‚       â””â”€â”€ (opcional)
    â”‚   â”‚   â”‚
    â”‚   â”‚   â”œâ”€â”€ helm-values/
    â”‚   â”‚   â”‚   â”œâ”€â”€ dev/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ kube-prometheus-stack.values.yaml
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ loki.values.yaml
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ tempo.values.yaml
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ otel-collector.values.yaml
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ keda.values.yaml
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ingress-nginx.values.yaml
    â”‚   â”‚   â”‚
    â”‚   â”‚   â””â”€â”€ argocd/
    â”‚   â”‚       â”œâ”€â”€ bootstrap/
    â”‚   â”‚       â”‚   â””â”€â”€ application-bootstrap.yaml
    â”‚   â”‚       â”œâ”€â”€ projects/
    â”‚   â”‚       â”‚   â””â”€â”€ project-platform.yaml
    â”‚   â”‚       â””â”€â”€ applications/
    â”‚   â”‚           â”œâ”€â”€ platform-observability.yaml
    â”‚   â”‚           â””â”€â”€ platform-autoscaling.yaml
    â”‚   â”‚           â””â”€â”€ platform-ingress-nginx.yaml
    â”‚   â”‚
    â”‚   â””â”€â”€ apps/
    â”‚       â”œâ”€â”€ README.md
    â”‚       â”œâ”€â”€ base/
    â”‚       â”‚   â”œâ”€â”€ identity/
    â”‚       â”‚   â”œâ”€â”€ farm/
    â”‚       â”‚   â”œâ”€â”€ sensor-ingest/
    â”‚       â”‚   â”œâ”€â”€ analytics-worker/
    â”‚       â”‚   â”œâ”€â”€ dashboard/
    â”‚       â”‚   â””â”€â”€ kustomization.yaml
    â”‚       â”œâ”€â”€ overlays/
    â”‚       â”‚   â”œâ”€â”€ dev/
    â”‚       â”‚   â”‚   â””â”€â”€ kustomization.yaml
    â”‚       â””â”€â”€ argocd/
    â”‚           â”œâ”€â”€ projects/
    â”‚           â”‚   â””â”€â”€ project-apps.yaml
    â”‚           â””â”€â”€ applications/
    â”‚               â”œâ”€â”€ apps-dev.yaml
    â”‚

---

## ğŸ§© Arquivos principais (conteÃºdo sugerido)

### 1) platform/argocd/bootstrap/application-bootstrap.yaml (App-of-apps)
Este Ã© o arquivo que vocÃª aplica UMA vez apÃ³s instalar ArgoCD.
Ele cria as aplicaÃ§Ãµes de platform (observability + autoscaling).

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: platform-bootstrap
  namespace: argocd
spec:
  project: platform
  source:
    repoURL: https://github.com/<ORG>/<REPO>.git
    targetRevision: main
    path: infrastructure/kubernetes/platform/argocd/applications
    directory:
      recurse: true
  destination:
    server: https://kubernetes.default.svc
    namespace: argocd
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=true
```

> ObservaÃ§Ã£o: esse App-of-apps aponta para a pasta `applications/` e o ArgoCD vai criar tudo que tiver ali.

---

### 2) platform/argocd/projects/project-platform.yaml
```yaml
apiVersion: argoproj.io/v1alpha1
kind: AppProject
metadata:
  name: platform
  namespace: argocd
spec:
  description: Platform components (observability, autoscaling, ingress, etc)
  sourceRepos:
    - '*'
  destinations:
    - namespace: '*'
      server: https://kubernetes.default.svc
  clusterResourceWhitelist:
    - group: '*'
      kind: '*'
```

---

### 3) platform/argocd/applications/platform-observability.yaml
Instala Prometheus/Grafana/Loki/Tempo/OTel Collector via Helm.

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: platform-observability
  namespace: argocd
spec:
  project: platform
  destination:
    server: https://kubernetes.default.svc
    namespace: monitoring
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=true
  sources:
    # kube-prometheus-stack
    - repoURL: https://prometheus-community.github.io/helm-charts
      chart: kube-prometheus-stack
      targetRevision: 65.0.0
      helm:
        valueFiles:
          - $values/infrastructure/kubernetes/platform/helm-values/dev/kube-prometheus-stack.values.yaml

    # Loki (chart oficial)
    - repoURL: https://grafana.github.io/helm-charts
      chart: loki
      targetRevision: 6.16.0
      helm:
        valueFiles:
          - $values/infrastructure/kubernetes/platform/helm-values/dev/loki.values.yaml

    # Tempo
    - repoURL: https://grafana.github.io/helm-charts
      chart: tempo
      targetRevision: 1.10.3
      helm:
        valueFiles:
          - $values/infrastructure/kubernetes/platform/helm-values/dev/tempo.values.yaml

    # OpenTelemetry Collector
    - repoURL: https://open-telemetry.github.io/opentelemetry-helm-charts
      chart: opentelemetry-collector
      targetRevision: 0.105.0
      helm:
        valueFiles:
          - $values/infrastructure/kubernetes/platform/helm-values/dev/otel-collector.values.yaml

    # Values repository (mesmo repo git)
    - repoURL: https://github.com/<ORG>/<REPO>.git
      targetRevision: main
      ref: values
```

> Nota: esse modelo usa "multi-source Application" (ArgoCD). Ã‰ a forma mais limpa de versionar values no seu repo e instalar charts externos.

---

### 4) platform/argocd/applications/platform-autoscaling.yaml (KEDA)
```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: platform-autoscaling
  namespace: argocd
spec:
  project: platform
  destination:
    server: https://kubernetes.default.svc
    namespace: keda
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=true
  sources:
    - repoURL: https://kedacore.github.io/charts
      chart: keda
      targetRevision: 2.15.1
      helm:
        valueFiles:
          - $values/infrastructure/kubernetes/platform/helm-values/dev/keda.values.yaml
    - repoURL: https://github.com/<ORG>/<REPO>.git
      targetRevision: main
      ref: values
```

---

## ğŸš€ Workflow (1 comando e GitOps assume)

1) Rodar bootstrap (host-level):
- Cria cluster k3d
- Instala ArgoCD
- Aplica `application-bootstrap.yaml`

2) ArgoCD instala automaticamente:
- kube-prometheus-stack (Prometheus/Grafana)
- Loki
- Tempo
- OpenTelemetry Collector
- KEDA
- ingress

3) Depois vocÃª adiciona as apps em `infrastructure/kubernetes/apps/argocd/applications/`

---

## ObservaÃ§Ãµes prÃ¡ticas (importantes)
- VocÃª pode ter values separados por ambiente:
  - dev: limites menores e retenÃ§Ã£o curta
  - prod: limites maiores e persistÃªncia real
- Para k3d com node pools (system/apps):
  - aplique nodeSelector/tolerations nos values de platform para cair no node `agentpool=system`
  - apps ficam no `agentpool=apps`
- Se quiser, dÃ¡ pra evoluir para:
  - ApplicationSets por ambiente
  - Projects com RBAC por time
  - Regras de sync waves (observability antes de apps)

---

usar arquivos abaixo como referencia e ajustar de acordo com o nosso contexto
ğŸ§© Arquivos principais (conteÃºdo sugerido)
1) platform/argocd/bootstrap/application-bootstrap.yaml (App-of-apps)
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: platform-bootstrap
  namespace: argocd
spec:
  project: platform
  source:
    repoURL: https://github.com/<ORG>/<REPO>.git
    targetRevision: main
    path: infrastructure/kubernetes/platform/argocd/applications
    directory:
      recurse: true
  destination:
    server: https://kubernetes.default.svc
    namespace: argocd
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=true

2) platform/argocd/projects/project-platform.yaml
apiVersion: argoproj.io/v1alpha1
kind: AppProject
metadata:
  name: platform
  namespace: argocd
spec:
  description: Platform components (observability, autoscaling, ingress, etc)
  sourceRepos:
    - '*'
  destinations:
    - namespace: '*'
      server: https://kubernetes.default.svc
  clusterResourceWhitelist:
    - group: '*'
      kind: '*'

3) platform/argocd/applications/platform-observability.yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: platform-observability
  namespace: argocd
spec:
  project: platform
  destination:
    server: https://kubernetes.default.svc
    namespace: monitoring
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=true
  sources:
    - repoURL: https://prometheus-community.github.io/helm-charts
      chart: kube-prometheus-stack
      targetRevision: 65.0.0
      helm:
        valueFiles:
          - $values/infrastructure/kubernetes/platform/helm-values/dev/kube-prometheus-stack.values.yaml

    - repoURL: https://grafana.github.io/helm-charts
      chart: loki
      targetRevision: 6.16.0
      helm:
        valueFiles:
          - $values/infrastructure/kubernetes/platform/helm-values/dev/loki.values.yaml

    - repoURL: https://grafana.github.io/helm-charts
      chart: tempo
      targetRevision: 1.10.3
      helm:
        valueFiles:
          - $values/infrastructure/kubernetes/platform/helm-values/dev/tempo.values.yaml

    - repoURL: https://open-telemetry.github.io/opentelemetry-helm-charts
      chart: opentelemetry-collector
      targetRevision: 0.105.0
      helm:
        valueFiles:
          - $values/infrastructure/kubernetes/platform/helm-values/dev/otel-collector.values.yaml

    - repoURL: https://github.com/<ORG>/<REPO>.git
      targetRevision: main
      ref: values

4) platform/argocd/applications/platform-autoscaling.yaml (KEDA)
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: platform-autoscaling
  namespace: argocd
spec:
  project: platform
  destination:
    server: https://kubernetes.default.svc
    namespace: keda
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=true
  sources:
    - repoURL: https://kedacore.github.io/charts
      chart: keda
      targetRevision: 2.15.1
      helm:
        valueFiles:
          - $values/infrastructure/kubernetes/platform/helm-values/dev/keda.values.yaml
    - repoURL: https://github.com/<ORG>/<REPO>.git
      targetRevision: main
      ref: values

# Platform Ingress NGINX + ArgoCD Ingress (host-based)
# ======================================================
# Files generated (logical split):
# 1) infrastructure/kubernetes/platform/argocd/applications/platform-ingress-nginx.yaml
# 2) infrastructure/kubernetes/platform/helm-values/dev/ingress-nginx.values.yaml
# 3) infrastructure/kubernetes/platform/base/ingress/argocd-ingress.yaml   (optional - plain manifest)
#
# Notes:
# - This assumes you have a k3d cluster with port mappings:
#     --port "80:80@loadbalancer" --port "443:443@loadbalancer"
# - We schedule ingress-nginx on the "system" node pool using nodeSelector + tolerations.
# - The ArgoCD Ingress is host-based: argocd.local -> argocd-server (HTTP)
# - For local dev, TLS is optional; here we keep it HTTP to simplify.
#
# Replace <ORG>/<REPO> in the ArgoCD Application with your repo.
# If you use a different domain than *.local, update hosts accordingly.

---
# 1) platform-ingress-nginx.yaml (ArgoCD Application)
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: platform-ingress-nginx
  namespace: argocd
spec:
  project: platform
  destination:
    server: https://kubernetes.default.svc
    namespace: ingress-nginx
  syncPolicy:
    automated:
      prune: true
      selfHeal: true
    syncOptions:
      - CreateNamespace=true
  sources:
    - repoURL: https://kubernetes.github.io/ingress-nginx
      chart: ingress-nginx
      targetRevision: 4.11.3
      helm:
        valueFiles:
          - $values/infrastructure/kubernetes/platform/helm-values/dev/ingress-nginx.values.yaml
    - repoURL: https://github.com/<ORG>/<REPO>.git
      targetRevision: main
      ref: values

---
# 2) ingress-nginx.values.yaml (DEV)
# Path: infrastructure/kubernetes/platform/helm-values/dev/ingress-nginx.values.yaml
controller:
  kind: Deployment

  # IMPORTANT: keep this service as LoadBalancer in k3d.
  # k3d will provide a loadbalancer container and map host ports 80/443 to it.
  service:
    type: LoadBalancer

  # Schedule ingress controller on system pool
  nodeSelector:
    agentpool: system

  tolerations:
    - key: "agentpool"
      operator: "Equal"
      value: "system"
      effect: "NoSchedule"

  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 500m
      memory: 512Mi

  # Optional: reduce noise in local
  config:
    enable-access-log: "true"

---
# 3) ArgoCD Ingress (host-based) - plain manifest
# Path suggestion: infrastructure/kubernetes/platform/base/ingress/argocd-ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: argocd-ingress
  namespace: argocd
  annotations:
    nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
spec:
  ingressClassName: nginx
  rules:
    - host: argocd.local
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: argocd-server
                port:
                  number: 80
