Rodrigo — recomendação prática (e “padrão de mercado”) para k3d + stack APM full, com Windows e macOS
================================================================================

Objetivo
--------
Você quer:
- Criar o cluster local com k3d
- Instalar ArgoCD + Prometheus/Grafana + Loki + Tempo + OTel Collector + KEDA
- Fazer isso rodar igual em Windows e macOS
- Manter o bootstrap (script) o menor possível
- Versionar tudo no repositório (reprodutível, auditável, fácil de manter)

A melhor abordagem: 2 camadas (Host-level vs Cluster-level)
-----------------------------------------------------------

1) Camada Host-level (depende do SO)
------------------------------------
Essa parte “inevitavelmente” envolve o sistema operacional porque depende de:
- Docker Desktop / Docker Engine
- k3d
- portas e port-mapping
- registry local
- kubeconfig/context

Aqui faz sentido usar um script de bootstrap pequeno, por exemplo:
- PowerShell 7+ (pwsh) → cross-platform (Windows/macOS/Linux)
ou
- bash (se você padronizar WSL/Git Bash no Windows)

Recomendação: usar pwsh
-----------------------
Como você já está usando .ps1, a melhor escolha é PowerShell 7+ (pwsh):
- roda em Windows e macOS
- mantém 1 script único
- evita duplicar automação em bash + ps1

O bootstrap deve fazer SOMENTE:
-------------------------------
- Validar dependências (docker, k3d, kubectl, helm)
- Criar registry local (se necessário)
- Criar o cluster k3d (1 server + 2 agents)
- Ajustar kubeconfig/context
- Aplicar labels/taints (system/apps) para simular node pools
- Criar namespaces básicos

Ou seja: o script faz “infra do cluster”, não instala tudo “na mão”.

2) Camada Cluster-level (Kubernetes state, igual em qualquer OS)
---------------------------------------------------------------
Tudo que roda DENTRO do Kubernetes deve ser instalado de forma idêntica em qualquer SO, usando:
- Helm (charts) + values.yaml versionados
- kubectl apply com manifests YAML versionados
- (opcional e ideal) ArgoCD (GitOps) para “assumir” a gestão depois do bootstrap

Isso garante:
- repetibilidade
- padronização
- facilidade de PR/review
- menos dependência do script
- menos chance de “funciona no Windows mas não no Mac”

O que é “correto” instalar via Helm/Manifests (e não hardcoded no script)
-------------------------------------------------------------------------
Componentes que devem ser cluster-level:
- ArgoCD
- kube-prometheus-stack (Prometheus + Grafana + Alertmanager)
- Loki (logs)
- Tempo (traces)
- OpenTelemetry Collector (hub de ingestão/export)
- KEDA (event-driven autoscaling)

Por que não colocar tudo dentro do PS1?
--------------------------------------
Dá para fazer, mas vira dor de cabeça com o tempo:

- Script cresce demais
- Cada ajuste de config vira edição de script
- Menos “GitOps friendly”
- Pior para versionamento e revisão (PR)
- Mais difícil reaproveitar em CI/CD
- Difícil reaplicar incrementalmente sem efeitos colaterais

A solução “limpa” é: Helm + values.yaml versionados
---------------------------------------------------
Você mantém configurações em arquivos declarativos no repositório, por exemplo:

/platform
  /helm-values
    argocd.values.yaml
    kube-prometheus-stack.values.yaml
    loki.values.yaml
    tempo.values.yaml
    otel-collector.values.yaml
    keda.values.yaml

  /manifests
    namespaces.yaml
    ingress.yaml
    (labels/taints se preferir declarar também)

E aplica com comandos que funcionam igual em qualquer OS:
- helm upgrade --install ... -f values.yaml
- kubectl apply -f manifests/

Estratégia recomendada: Bootstrap mínimo + ArgoCD “assume” tudo depois
---------------------------------------------------------------------
Fluxo ideal (GitOps de verdade):
1) bootstrap cria cluster k3d + registry + labels/taints
2) bootstrap instala apenas o ArgoCD
3) ArgoCD instala o resto da stack (Prometheus/Grafana/Loki/Tempo/OTel/KEDA)
4) ArgoCD instala suas apps

Benefícios:
- você faz o cluster “subir” com 1 comando
- todo o resto vem do Git
- seu ambiente fica muito parecido com produção (modelo GitOps)

Como isso ajuda no Windows + macOS?
----------------------------------
Porque depois que o cluster existe:
- o que muda entre Windows e macOS é praticamente ZERO
- o mesmo conjunto de YAML/Helm funciona nos dois
- o script fica pequeno e “burrinho” (só bootstrap)

Recomendação final (resumo)
--------------------------
✔ Criar cluster k3d via script (pwsh) é correto e esperado
✔ Instalar stack (ArgoCD/Prom/Loki/Tempo/OTel/KEDA) via Helm + values.yaml versionados é o melhor padrão
✔ Manter o script mínimo reduz complexidade e aumenta portabilidade
✔ Ideal: instalar ArgoCD no bootstrap e deixar ele gerenciar todo o resto (GitOps)

Resposta curta “para alinhamento com o time” (copy/paste)
--------------------------------------------------------
“The k3d cluster creation is host-level, so we’ll keep a small cross-platform bootstrap script (pwsh) for cluster + registry + ports + node labels/taints. Everything inside the cluster (ArgoCD, KEDA, Prometheus/Grafana, Loki, Tempo, OTel Collector) should be installed using Helm charts + versioned values.yaml and/or Kubernetes manifests applied via kubectl. This keeps the bootstrap minimal and ensures the same installation works on Windows and macOS.”
